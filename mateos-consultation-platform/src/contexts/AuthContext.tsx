/* eslint-disable react-refresh/only-export-components */
import { convertUserDtoToUser } from '@/lib/converters';
import { AuthService } from '@/services/authService';
import { UserService } from '@/services/userService';
import { SessionDto, User, UserRole } from '@/types';
import { DeviceInfoService } from '@/utils/deviceInfo';
import { createContext, ReactNode, useContext, useEffect, useReducer } from 'react';

interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  currentSession: SessionDto | null;
}

interface AuthContextType extends AuthState {
  login: (email: string, password: string, rememberDevice?: boolean) => Promise<SessionDto | null>;
  register: (userData: RegisterData) => Promise<SessionDto | null>;
  logout: () => void;
  setCurrentSession: (session: SessionDto | null) => void;
}

interface RegisterData {
  email: string;
  password: string;
  firstname: string;
  lastname: string;
  role: UserRole;
  phoneNumber?: string;
  hasAcceptedPrivacyPolicy: boolean;
  hasAcceptedTerms: boolean;
  hasAcceptedMarketing?: boolean;
  hasAcceptedCookies?: boolean;
  hasAcceptedAttendanceTracking?: boolean;
  hasAcceptedPaymentTracking?: boolean;
  hasAcceptedGroupPlacement?: boolean;
  hasAcceptedScheduleTracking?: boolean;
  studentName?: string;
  parentName?: string;
}

type AuthAction =
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_USER'; payload: User }
  | { type: 'SET_SESSION'; payload: SessionDto | null }
  | { type: 'CLEAR_USER' };

const initialState: AuthState = {
  user: null,
  isLoading: true,
  isAuthenticated: false,
  currentSession: null,
};

function authReducer(state: AuthState, action: AuthAction): AuthState {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    case 'SET_USER':
      return {
        ...state,
        user: action.payload,
        isAuthenticated: true,
        isLoading: false,
      };
    case 'SET_SESSION':
      return {
        ...state,
        currentSession: action.payload,
      };
    case 'CLEAR_USER':
      return {
        ...state,
        user: null,
        isAuthenticated: false,
        isLoading: false,
        currentSession: null,
      };
    default:
      return state;
  }
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  useEffect(() => {
    let isInitializing = false;
    
    // VerificƒÉm prezen»õa token-ului la √ÆncƒÉrcare
    const initializeAuth = async () => {
      // –ó–∞—â–∏—Ç–∞ –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤
      if (isInitializing) {
        console.log('üîÑ Auth initialization already in progress, skipping...');
        return;
      }
      
      isInitializing = true;
      console.log('üöÄ Starting auth initialization...');
      
      const token = localStorage.getItem('authToken');
      
      if (token) {
        try {
          // –°–ø–æ—á–∞—Ç–∫—É —Å–ø—Ä–æ–±—É—î–º–æ –∑—Ä–æ–±–∏—Ç–∏ refresh token, —è–∫—â–æ –æ—Å–Ω–æ–≤–Ω–∏–π —Ç–æ–∫–µ–Ω –∑–∞—Å—Ç–∞—Ä—ñ–≤
          console.log('üîç Checking token validity...');
          
          // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –∏–∑ API
          const userProfile = await UserService.getProfile();
          const user = convertUserDtoToUser(userProfile);
          
          dispatch({ type: 'SET_USER', payload: user });
          
          // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
          localStorage.setItem('user', JSON.stringify(user));
          
          // üîß NEW: –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–µ—Å—Å–∏–∏
          const session = AuthService.getCurrentSession();
          if (session) {
            dispatch({ type: 'SET_SESSION', payload: session });
            console.log('‚úÖ Session restored:', session);
          }
          
          console.log('‚úÖ User restored from API:', user);
          
          // –ü–æ–∫–∞ –æ—Ç–∫–ª—é—á–∏–º SignalR
          // notificationService.connect(user.id);
        } catch (error) {
          console.error('‚ùå Eroare la restaurarea utilizatorului:', error);
          // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ —Å–≤—è–∑–∞–Ω–∞ —Å –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π (401) - –æ—á–∏—â–∞–µ–º —Ç–æ–∫–µ–Ω—ã
          if (error instanceof Error && error.message.includes('Authentication expired')) {
            console.warn('üîê Token expired, clearing auth data');
            localStorage.removeItem('authToken');
            // üîê SECURITY: refreshToken este acum √Æn HttpOnly cookie (gestionat de backend)
            localStorage.removeItem('user');
            localStorage.removeItem('currentSession');
          } else if (error instanceof Error && (error.message.includes('Failed to fetch') || error.message.includes('CORS'))) {
            console.warn('‚ö†Ô∏è Network error during auth restoration, keeping tokens');
            // –ü—Ä–∏ —Å–µ—Ç–µ–≤—ã—Ö –æ—à–∏–±–∫–∞—Ö –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            const cachedUser = localStorage.getItem('user');
            if (cachedUser) {
              try {
                const user = JSON.parse(cachedUser);
                dispatch({ type: 'SET_USER', payload: user });
                console.log('‚úÖ Using cached user data during network error');
              } catch {
                console.error('‚ùå Failed to parse cached user data');
              }
            }
          } else {
            console.error('‚ùå Unexpected error during auth restoration:', error);
            localStorage.removeItem('authToken');
            // üîê SECURITY: refreshToken este acum √Æn HttpOnly cookie (gestionat de backend)
            localStorage.removeItem('user');
            localStorage.removeItem('currentSession');
          }
        }
      }
      
      dispatch({ type: 'SET_LOADING', payload: false });
      isInitializing = false;
      console.log('üèÅ Auth initialization completed');
    };
    
    initializeAuth();
  }, []);

  const login = async (email: string, password: string, rememberDevice = false) => {
    try {
      // üßπ –°–ø–æ—á–∞—Ç–∫—É –æ—á–∏—â–∞—î–º–æ –≤—Å—ñ —Å—Ç–∞—Ä—ñ —Ç–æ–∫–µ–Ω–∏ –ø–µ—Ä–µ–¥ –Ω–æ–≤–∏–º –ª–æ–≥—ñ–Ω–æ–º
      console.log('üßπ Cleaning old tokens before new login...');
      localStorage.removeItem('authToken');
      localStorage.removeItem('user');
      localStorage.removeItem('currentSession');
      AuthService.clearSession();
      
      // –¢–∞–∫–æ–∂ –≤–∏–∫–ª–∏–∫–∞—î–º–æ logout –Ω–∞ backend, —â–æ–± –æ—á–∏—Å—Ç–∏—Ç–∏ HttpOnly cookie
      try {
        await AuthService.logout();
      } catch (error) {
        // –Ü–≥–Ω–æ—Ä—É—î–º–æ –ø–æ–º–∏–ª–∫–∏ logout –ø–µ—Ä–µ–¥ –ª–æ–≥—ñ–Ω–æ–º (–º–æ–∂–ª–∏–≤–æ, –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –≤–∂–µ —Ä–æ–∑–ª–æ–≥—ñ–Ω–µ–Ω–∏–π)
        console.log('‚ö†Ô∏è Logout before login failed (expected if not logged in):', error);
      }
      dispatch({ type: 'SET_LOADING', payload: true });
      
      // üîß ColectƒÉm informa»õii despre dispozitiv
      const deviceInfo = DeviceInfoService.getAllDeviceInfo();
      console.log('üì± Device info collected:', deviceInfo);
      
      // üîß Apelam API pentru login cu informa»õii despre dispozitiv
      const response = await AuthService.loginWithDeviceInfo(
        { email, password },
        deviceInfo,
        rememberDevice
      );
      
      console.log('‚úÖ Login response:', response);
      
      // VerificƒÉm dacƒÉ rƒÉspunsul con»õine success »ôi e false
      if (response.success === false) {
        throw new Error(response.message || 'Eroare la autentificare');
      }
      
      // VerificƒÉm dacƒÉ avem token
      if (!response.token) {
        throw new Error('RƒÉspuns invalid de la server: lipsƒÉ token');
      }
      
      // Extragem datele din rƒÉspunsul API
      const { token, user: userDto, session } = response;
      
      console.log('üîë Token primit:', token ? 'Da' : 'Nu');
      console.log('üë§ User from response:', userDto);
      console.log('üì± Session from response:', session);
      
      // üîê SECURITY: SalvƒÉm doar access token √Æn localStorage
      // Refresh token este acum √Æn HttpOnly cookie (backend √Æl seteazƒÉ automat)
      localStorage.setItem('authToken', token);
      
      // Folosim datele utilizatorului din rƒÉspunsul login
      const user = convertUserDtoToUser(userDto);
      console.log('‚úÖ Converted user:', user);
      
      // SalvƒÉm utilizatorul √Æn localStorage
      localStorage.setItem('user', JSON.stringify(user));
      
      dispatch({ type: 'SET_USER', payload: user });
      
      // üîß ProcessƒÉm informa»õiile despre sesiune
      if (session) {
        dispatch({ type: 'SET_SESSION', payload: session });
        
        // üîî Afi»ôƒÉm notificare pentru dispozitiv nou
        if (session.isNewDevice) {
          console.log('üîî Dispozitiv nou detectat:', {
            deviceName: session.deviceName,
            deviceType: session.deviceType,
            browser: session.browser,
            platform: session.platform,
          });
          // TODO: AratƒÉ utilizatorului notificare prin NotificationService
          // NotificationService.showSecurityAlert('newDevice', session);
        }
      }
      
      // DezactivƒÉm SignalR pentru moment
      // await notificationService.connect(user.id);
      
      // üîß Returnam session pentru procesare √Æn pagina de login
      return session || null;
    } catch (error) {
      console.error('‚ùå Login error:', error);
      
      // √émbunƒÉtƒÉ»õire a tratƒÉrii erorilor
      let errorMessage = 'Eroare la autentificare';
      
      if (error instanceof Error) {
        const apiError = error as Error & { status?: number; data?: { message?: string; success?: boolean } };
        
        if (apiError.status === 401 || apiError.data?.success === false) {
          errorMessage = apiError.data?.message || 'Email sau parolƒÉ incorectƒÉ';
        } else if (apiError.status === 500) {
          errorMessage = 'Eroare de server. √éncerca»õi mai t√¢rziu.';
        } else if (apiError.message) {
          errorMessage = apiError.message;
        }
      }
      
      // CurƒÉ»õƒÉm token-urile la eroare
      localStorage.removeItem('authToken');
      // üîê SECURITY: Nu mai »ôtergem refreshToken din localStorage (este √Æn cookie)
      localStorage.removeItem('user');
      dispatch({ type: 'SET_LOADING', payload: false });
      
      // CreƒÉm eroare cu mesaj clar
      const userFriendlyError = new Error(errorMessage);
      throw userFriendlyError;
    }
  };

  const register = async (userData: RegisterData) => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      // üîß ColectƒÉm informa»õii despre dispozitiv
      const deviceInfo = DeviceInfoService.getAllDeviceInfo();
      console.log('üì± Device info collected for registration:', deviceInfo);
      
      // ConvertƒÉm rolul √Æn formatul corect pentru API
      const convertedRole = userData.role === 'student' ? 'Student' : 
                           userData.role === 'teacher' ? 'Teacher' :
                           userData.role === 'admin' ? 'Administrator' :
                           userData.role;

      // Ob»õinem User Agent pentru consent tracking
      const consentUserAgent = navigator.userAgent;
      const consentIPAddress = 'client'; // IP-ul va fi determinat pe server

      // üîß ApelƒÉm API pentru √Ænregistrare cu informa»õii despre dispozitiv »ôi consim»õƒÉminte GDPR
      const response = await AuthService.registerWithDeviceInfo(
        {
          role: convertedRole as string,
          name: userData.firstname,
          surname: userData.lastname,
          email: userData.email,
          password: userData.password,
          phoneNumber: userData.phoneNumber,
          hasAcceptedPrivacyPolicy: userData.hasAcceptedPrivacyPolicy,
          hasAcceptedTerms: userData.hasAcceptedTerms,
          hasAcceptedMarketing: userData.hasAcceptedMarketing,
          hasAcceptedCookies: userData.hasAcceptedCookies,
          hasAcceptedAttendanceTracking: userData.hasAcceptedAttendanceTracking,
          hasAcceptedPaymentTracking: userData.hasAcceptedPaymentTracking,
          hasAcceptedGroupPlacement: userData.hasAcceptedGroupPlacement,
          hasAcceptedScheduleTracking: userData.hasAcceptedScheduleTracking,
          studentName: userData.studentName,
          parentName: userData.parentName,
          consentTimestamp: new Date().toISOString(),
          consentIPAddress,
          consentUserAgent,
        },
        deviceInfo
      );
      
      console.log('‚úÖ Register response:', response);
      
      // ‚ö†Ô∏è –í–ê–ñ–ù–û: RegisterResponse –ù–ï —Å–æ–¥–µ—Ä–∂–∏—Ç success/message/session —Å–æ–≥–ª–∞—Å–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏!
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞–ª–∏—á–∏–µ token
      if (!response.token) {
        throw new Error('RƒÉspuns invalid de la server: lipsƒÉ token');
      }
      
      // Extragem datele din rƒÉspunsul API
      const { token, refreshToken, user: userDto } = response;
      
      console.log('üîë Register Token primit:', token ? 'Da' : 'Nu');
      console.log('üë§ User from register response:', userDto);
      
      // üîê SECURITY: SalvƒÉm doar access token √Æn localStorage
      // Refresh token este acum √Æn HttpOnly cookie (backend √Æl seteazƒÉ automat)
      localStorage.setItem('authToken', token);
      
      // üîê SECURITY: Nu mai salvƒÉm refreshToken √Æn localStorage
      // Backend-ul √Æl seteazƒÉ automat √Æn HttpOnly cookie la register
      if (refreshToken) {
        console.log('‚ö†Ô∏è RefreshToken primit √Æn response (backward compatibility), dar nu √Æl salvƒÉm - folosim cookie');
      }
      
      // ConvertƒÉm UserDto √Æn User
      const user = convertUserDtoToUser(userDto);
      
      // SalvƒÉm utilizatorul √Æn localStorage
      localStorage.setItem('user', JSON.stringify(user));
      
      dispatch({ type: 'SET_USER', payload: user });
      
      console.log('‚úÖ √énregistrare reu»ôitƒÉ pentru:', user.email);
      
      // DezactivƒÉm SignalR pentru moment
      // await notificationService.connect(user.id);
      
      // Register nu returneazƒÉ session conform documenta»õiei
      return null;
    } catch (error) {
      console.error('‚ùå Register error:', error);
      
      // √émbunƒÉtƒÉ»õirea tratƒÉrii erorilor
      let errorMessage = 'Eroare la √Ænregistrare';
      
      if (error instanceof Error) {
        const apiError = error as Error & { 
          status?: number; 
          data?: { 
            message?: string; 
            errors?: Record<string, string[]>;
          } 
        };
        
        if (apiError.status === 400) {
          // Erori de validare - parseaza errors object
          if (apiError.data?.errors) {
            const errorMessages = Object.values(apiError.data.errors).flat();
            errorMessage = errorMessages.join(', ');
          } else if (apiError.data?.message) {
            errorMessage = apiError.data.message;
          } else {
            errorMessage = 'Date invalide. VerificƒÉ toate c√¢mpurile.';
          }
        } else if (apiError.status === 409) {
          errorMessage = 'Email-ul este deja √Ænregistrat.';
        } else if (apiError.status === 500) {
          errorMessage = 'Eroare de server. √éncerca»õi mai t√¢rziu.';
        } else if (apiError.message) {
          errorMessage = apiError.message;
        }
      }
      
      // CurƒÉ»õƒÉm token-urile la eroare
      localStorage.removeItem('authToken');
      // üîê SECURITY: refreshToken este acum √Æn HttpOnly cookie (gestionat de backend)
      localStorage.removeItem('user');
      localStorage.removeItem('currentSession');
      dispatch({ type: 'SET_LOADING', payload: false });
      
      // CreƒÉm eroare cu mesaj clar
      const userFriendlyError = new Error(errorMessage);
      throw userFriendlyError;
    }
  };

  const logout = async () => {
    try {
      // üîê SECURITY: Nu mai citim refreshToken din localStorage
      // Backend-ul √Æl va citi automat din HttpOnly cookie
      // ApelƒÉm endpoint-ul de logout care va clear-ui cookie-ul
      await AuthService.logout();
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ logout:', error);
    }
    
    // –û—á–∏—â–∞–µ–º —Å–µ—Å—Å–∏—é
    AuthService.clearSession();
    
    // –û—á–∏—â–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
    localStorage.removeItem('authToken');
    // üîê SECURITY: refreshToken este acum √Æn HttpOnly cookie (gestionat de backend)
    localStorage.removeItem('user');
    localStorage.removeItem('currentSession');
    
    dispatch({ type: 'CLEAR_USER' });
  };

  const value: AuthContextType = {
    ...state,
    login,
    register,
    logout,
    setCurrentSession: (session) => dispatch({ type: 'SET_SESSION', payload: session }), // üîß NEW
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}
